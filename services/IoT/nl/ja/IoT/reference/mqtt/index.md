---

copyright:
  years: 2015, 2016

---

{:new_window: target="\_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}


# MQTT メッセージング
{: #ref-mqtt}
最終更新日: 2016 年 9 月 13 日
{: .last-updated}

MQTT は、デバイスとアプリケーションが {{site.data.keyword.iot_full}} と通信するために使用する主要なプロトコルです。MQTT は、パブリッシュ/サブスクライブ・メッセージング・トランスポート・プロトコルで、センサーとモバイル・デバイスの間でリアルタイム・データを効率的に交換するために設計されています。
{:shortdesc}

MQTT は TCP/IP で実行されます。TCP/IP の直接コーディングも可能ですが、MQTT プロトコルの詳細を処理するライブラリーを使用することもできます。広範囲の MQTT クライアント・ライブラリーが用意されています。IBM は、いくつかのクライアント・ライブラリーの開発やサポートに寄与しています。それには以下のサイトで利用可能なものが含まれます。

- [MQTT コミュニティー Wiki](https://github.com/mqtt/mqtt.github.io/wiki)
- [Eclipse Paho プロジェクト](http://eclipse.org/paho/)

## バージョン・サポート
{: #version-support}

{{site.data.keyword.iot_short_notm}} では、MQTT メッセージ・プロトコルの以下のバージョンがサポートされています。

MQTT バージョン | 以前との相違点 | 注
--- | --- | ---
[3.1.1](https://www.oasis-open.org/standards#mqttv3.1.1) (推奨) | 共有サブスクリプションなどの保存メッセージはサポートされません。 | <ul><li>OASIS 規格。<li>ISO 規格 (ISO/IEC PRF 20922) <li>V3.1 に比べてプロトコルの定義がさらに厳密になったことによる、さまざまなクライアントとサーバーの間の相互運用性の改善。<li>MQTT クライアント ID (ClientId) の最大長が、V3.1 での 23 文字から 256 文字に増えました。</br>{{site.data.keyword.iot_short_notm}} サービスでは、今までより長いクライアント ID (ClientId) が必要になることがよくあります。</br>MQTT プロトコル・バージョンに関係なく長いクライアント ID がサポートされますが、V3.1 クライアント・ライブラリーの一部では、ClientId 値の長さが検査され、23 文字の制限が適用されます。</ul>
3.1 | - | MQTT V3.1 は、現在最も広く使用されているプロトコル・バージョンです。

{{site.data.keyword.iot_short_notm}} は、MQTT 規格で許可されている任意のコンテンツをサポートします。MQTT はデータの内容には関与しないため、画像、任意のエンコード方式のテキスト、暗号化データ、そして事実上あらゆるタイプのバイナリー形式データを送ることが可能です。MQTT 規格について詳しくは、以下のリソースを参照してください。
- [MQTT.org](http://mqtt.org/)
- [HiveMQ: Introducing MQTT](http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt)

## アプリケーション、デバイス、ゲートウェイの各クライアント
{: #device-app-clients}

{{site.data.keyword.iot_short_notm}} において、モノの主要なクラスはデバイスとアプリケーションです。ゲートウェイは、デバイスのサブクラスです。

MQTT クライアントがサービスに対して身分証明として提示するモノのクラスは、接続時にクライアントの機能を決めるものとなります。さらにモノのクラスにより、クライアント認証のメカニズムも決まります。

また、アプリケーションとデバイスは、異なる MQTT トピック・スペースで動作します。デバイスはデバイス・スコープのトピック・スペース内で動作する一方、アプリケーションには組織全体のトピック・スペースに対して全アクセス権限が付与されます。詳しくは、以下のトピックを参照してください。

- [デバイス](../../devices/mqtt.html)
- [アプリケーション](../../applications/mqtt.html)
- [ゲートウェイ](../../gateways/mqtt.html)

## サービス品質のレベル
{: #qos-levels}

MQTT プロトコルでは、クライアントとサーバーの間のメッセージ配信について、「最高 1 回」、「最低 1 回」、そして「ちょうど 1 回」の 3 つのサービス品質が提供されています。
イベントとコマンドの送信では任意のサービス品質レベルを使用できますが、実際のニーズに合った適切なサービス・レベルは何かを注意深く考慮する必要があります。サービス品質レベル 2 は、レベル 0 に比べて常により良いオプションになるとは限りません。

### 最高 1 回 (QoS0)

「最高 1 回」サービス品質レベル (QoS0) は、転送の最高速モードであり、「応答不要送信」とも呼ばれます。メッセージは最高 1 回配信されるか、あるいはまったく配信されません。ネットワークを通じての配信には肯定応答が送られず、メッセージは保管されません。クライアントが切断されるか、サーバーで障害が発生すると、メッセージが失われる可能性があります。

MQTT プロトコルでは、サーバーからクライアントへのパブリッシュをサービス品質レベル 0 で転送する必要はありません。サーバーがパブリケーションを受信した時点でクライアントが切断されていた場合、サーバーの実装方法によってはパブリケーションが破棄されることがあります。

**ヒント:** リアルタイム・データを一定の間隔で送信する場合は、サービス品質レベル 0 を使用します。1 つのメッセージが欠落しても、直後にそれより新しいデータが含まれる別のメッセージが送信されるため、実際には問題になりません。このシナリオの場合、高いサービス品質を使用することに余分のコストをかけても、それほどメリットはありません。

### 最低 1 回 (QoS1)

サービス品質レベル 1 (QoS1) の場合、メッセージは少なくとも 1 回は常に配信されます。送信元が確認応答を受け取るより前に障害が発生した場合、メッセージを複数回配信できます。メッセージがパブリッシュされたという受信側の確認を送信側が受信する時点まで、メッセージは送信側にローカルに保管されていなければなりません。メッセージが保管されるのは、メッセージの再送が必要になった場合に備えてのことです。

### ちょうど 1 回 (QoS2)

「ちょうど 1 回」サービス品質レベル (QoS2) は、安全性は最高ですが、転送速度は最低のモードです。メッセージは常にちょうど 1 回配信され、受信側によりメッセージがパブリッシュされたという確認を送信側が受信するまで送信元にもローカルに保管されなければなりません。メッセージが保管されるのは、メッセージの再送が必要になった場合に備えてのことです。サービス品質レベル 2 では、レベル 1 の場合より高度なハンドシェークと確認応答のシーケンスが使用され、メッセージの重複がないことが保証されます。

**ヒント:** コマンドを送信する際、指定されたコマンドのみアクションが実行されること、さらにそのアクションが 1 回のみであることの確認を受け取るには、サービス品質レベル 2 を使用します。これは、レベル 2 には付加的なオーバーヘッドがあっても他のレベルよりメリットがある場合の一例です。

## サブスクリプション・バッファーとクリーン・セッション
{: #subscription-buffers-and-clean-session}

デバイスまたはアプリケーションのいずれかからの各サブスクリプションには、5000 個のメッセージが入るバッファーが割り振られます。そのバッファーがあるので、アプリケーションやデバイスでライブ・データの処理が遅れても問題とはならず、サブスクリプションごとに保留メッセージが 5000 個まで入るバックログを構成することも可能になります。バッファーがいっぱいになった後、さらに新しいメッセージを受信すると、最も古いメッセージから破棄されます。

MQTT クリーン・セッション・オプションは、サブスクリプション・バッファーにアクセスするために使用します。クリーン・セッションが false に設定されている場合、サブスクライバーはバッファーからのメッセージを受信します。クリーン・セッションが true に設定されている場合、バッファーがリセットされます。

**注:** サブスクリプション・バッファー制限は、使用されるサービス品質の設定には関係なく適用されます。アプリケーションがサブスクリプションのメッセージ速度について行けない場合、レベル 1 または 2 で送信されるメッセージをアプリケーションに配信できない場合があります。

## メッセージ・ペイロードの制限
{: #message-payload}

{{site.data.keyword.iot_short_notm}} では、MQTT 規格で許可される任意の形式のメッセージの送受信がサポートされています。MQTT はデータの内容には関与しないため、画像、任意のエンコード方式のテキスト、暗号化データ、そして事実上あらゆるタイプのバイナリー形式データを送ることが可能です。しかし、特定のユース・ケースではいくつかの制限があります。   

また、{{site.data.keyword.iot_short_notm}} におけるメッセージ・ペイロードにはサイズの制限もあります。

### メッセージ・ペイロードのフォーマットの制限

メッセージ・ペイロードには有効な任意のストリングを含めることができますが、JSON (「json」)、テキスト (「text」)、そしてバイナリー (「bin」) フォーマットは、その他のフォーマット・タイプに比べて特に広く使用されます。

さまざまなフォーマット・タイプでのメッセージ・ペイロードの制限の概要を、以下の表に示します。

ペイロード・フォーマット  | 特定のユース・ケースでのガイドライン
--------- | ----------  
JSON | JSON は、{{site.data.keyword.iot_short_notm}} の標準形式です。組み込みの {{site.data.keyword.iot_short_notm}} ダッシュボード、ボードとカード、分析を使用する予定の場合、メッセージ・ペイロードのフォーマットが整形式 JSON テキストに準拠するようにしてください。
テキスト | 有効な UTF-8 文字エンコードを使用します。
バイナリー | 制限はありません。


### メッセージ・ペイロードの最大サイズ

**重要:** {{site.data.keyword.iot_short_notm}} のペイロードの最大サイズは、131072 バイトです。ペイロードがその制限を超えるメッセージは拒否されます。接続しているクライアントも切断され、以下のデバイス・メッセージの例に示されているようなメッセージが診断ログに表示されます。

`x.x.x.x からの接続が閉じられました。メッセージ・サイズがこのエンドポイントには大きすぎます。`
